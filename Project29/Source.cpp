#define _CRT_SECURE_NO_WARNINGS# include <iostream># include <assert.h>using namespace std;template <class NodeType>class List;template <class NodeType>class ListNode{	friend class List<NodeType>;public:	ListNode(const NodeType&);	NodeType getData()const;private:	NodeType data;	ListNode* nextPtr;};template<class NodeType>ListNode<NodeType>::ListNode(const NodeType& info){	data = info;	nextPtr = 0;}template<class NodeType>NodeType ListNode<NodeType>::getData() const { return data; }template <class NodeType>class List{public:	List();	List(const List&);	~List();	void insertAtFront(const NodeType&);	void insertAtBack(const NodeType&);	int removeFromFront(NodeType&);	int removeFromBack(NodeType&);	bool isEmpty() const { return firstPtr == 0; }	void print() const;	int addList();private:	ListNode<NodeType>* firstPtr;	ListNode<NodeType>* lastPtr;	ListNode<NodeType>* getNewNode(const NodeType&);};template<class NodeType>List<NodeType>::List(const List& l){	if (!l.isEmpty())	{		ListNode<NodeType>* currentPtr = l.firstPtr;		while (currentPtr != 0)		{			this->insertAtFront(currentPtr->data);			currentPtr = currentPtr->nextPtr;		}	}}template<class NodeType>List<NodeType>::List(){	firstPtr = lastPtr = 0;}template<class NodeType>List<NodeType>::~List(){	if (!isEmpty())	{		ListNode<NodeType> currentPtr = firstPtr, tempPtr;		while (currentPtr != 0)		{			tempPtr = currentPtr;			cout << tempPtr->data << " " << endl;			currentPtr = currentPtr->nextPtr;			delete tempPtr;		}	}}template<class NodeType>void List<NodeType>::insertAtFront(const NodeType& value){	ListNode<NodeType>* newPtr = getNewNode(value);	if (isEmpty())		firstPtr = lastPtr = newPtr;	else	{		newPtr->nextPtr = firstPtr;		firstPtr = newPtr;	}}template<class NodeType>void List<NodeType>::insertAtBack(const NodeType& value){	ListNode<NodeType>* newPtr = getNewNode(value);	if (isEmpty())		firstPtr = lastPtr = newPtr;	else	{		lastPtr->nextPtr = newPtr;		lastPtr = newPtr;	}}template<class NodeType>int List<NodeType>::removeFromFront(NodeType& value){	if (isEmpty())		return 0;	else	{		ListNode<NodeType>* tempPtr = firstPtr;		if (firstPtr == lastPtr)			firstPtr = lastPtr = 0;		else			firstPtr = firstPtr->nextPtr;		value = tempPtr->data;		delete tempPtr;		return 1;	}}template<class NodeType>int List<NodeType>::removeFromBack(NodeType& value){	if (isEmpty())		return 0;	else	{		ListNode<NodeType>* tempPtr = lastPtr;		if (firstPtr == lastPtr)			firstPtr = lastPtr = 0;		else		{			ListNode<NodeType>* currentPtr = firstPtr;			while (currentPtr->nextPtr != lastPtr)				currentPtr = currentPtr->nextPtr;			lastPtr = currentPtr;			currentPtr->nextPtr = 0;		}		value = tempPtr->data;		delete tempPtr;		return 1;	}}template<class NodeType>ListNode<NodeType>* List<NodeType>::getNewNode(const NodeType& value){	ListNode<NodeType>* ptr = new ListNode<NodeType>(value);	assert(ptr != 0);	return ptr;}template<class NodeType>int List<NodeType>::addList(){	if (isEmpty())		cout << "Список пуст" << endl;	ListNode<NodeType>* currentPtr = firstPtr;	while (currentPtr != 0)	{		return currentPtr->data;		currentPtr = currentPtr->nextPtr;	}}template<class NodeType>void List<NodeType>::print() const{	if (isEmpty())		cout << "Список пуст" << endl;	ListNode<NodeType>* currentPtr = firstPtr;	cout << "Список состоит из: ";	while (currentPtr != 0)	{		cout << currentPtr->data << " ";		currentPtr = currentPtr->nextPtr;	}	cout << endl;}struct shop {	char name[20];	char address[20];	char items[20];	int timebegin;	int timeend;	shop() {		name[0] = '\0';		address[0] = '\0';		items[0] = '\0';		timebegin = 0;		timeend = 0;	}	shop(const char n, const char a, const char* i, int t1, int t2) {		strcpy(name, n);		strcpy(address, a);		strcpy(items, i);		timebegin = t1;		timeend = t2;	}	friend ostream& operator<<(ostream& os, const shop& s);};ostream& operator<<(ostream& os, const shop& s) {	os << s.name << "\t" << s.address << "\t" << s.items << "\t" << s.timebegin << "\t" << s.timeend;	return os;}void main() {	List<shop> t;	system("pause");}